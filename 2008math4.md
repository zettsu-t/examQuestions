# 麻布中学校 2008年 入試問題 算数 問4

問題は以下の通りです。

http://www.inter-edu.com/nyushi/2008/azabu/

これは総当たりしかなさそうですね。

拙文で挙げた[プログラミング言語(リンク)](https://github.com/zettsu-t/zettsu-t.github.io/wiki/If-programming-languages-were)についてVBA以外で書き、Python, Groovy, Scheme, OCamlでも書きました。HTMLとCSSは除外、ということで。Cygwinターミナルから、makeを引数なしで実行すると、ビルド、実行、実行結果の検査を行います。

```bash
make
```

とにかくたくさんのプログラミング言語で書いてみることが本ページの目的なので、問4-2は以下の制限事項があります。
- 二組の整数から作る式を総当たりで比較しています。コードは簡潔になるかもしれませんが遅いです。可能であれば、計算結果を連想配列に入れることで、もっと速く計算できると思います。
- 問4-1でみたように、整数m..nに足し算掛け算を適用して作る計算結果は、同一の値に対して複数の式がありえます。そのときは表示が冗長になります。

## Ruby

メタプログラミングが使えます。コードを式として組み立てて、評価すると解けます。

```ruby
class ExprSet
  attr_reader :exprSet

  def initialize(minNum, maxNum)
    @exprSet = ((minNum+1)..maxNum).inject([minNum]) do |xs, i|
      xs.product(["+", "*"], [i])
    end.map(&:join)
  end

  def printSums
    puts @exprSet.map{ |expr| "#{eval(expr)} = #{expr}"}.sort_by(&:to_i)
  end

  def printMatchedSums(other)
    puts @exprSet.product(other.exprSet).map { |x| x.join(" == ") }.select { |x| eval x }
  end
end
```

```text
9 = 1*2+3+4
10 = 1+2+3+4
10 = 1*2*3+4
11 = 1+2*3+4
14 = 1*2+3*4
15 = 1+2+3*4
24 = 1*2*3*4
25 = 1+2*3*4
1+2+3*4+5 == 2+3+4+5+6
1*2+3+4*5 == 2+3*4+5+6
```

読みやすさを無視してソースコードをできる限り短くすると、[2008math4a.rb](2008math4a.rb)のように185 bytesになります。

```ruby
e=->(m,n){(m+1..n).inject([m]){|x,i|x.product(["+","*"],[i])}.map &:join}
p e[1,4].map{|x|"#{eval x}=#{x}"}.sort_by &:to_i
p e[1,5].product(e[2,6]).map{|x|x.join"=="}.select{|x|eval x}
```

```text
["9=1*2+3+4", "10=1+2+3+4", "10=1*2*3+4", "11=1+2*3+4",
 "14=1*2+3*4", "15=1+2+3*4", "24=1*2*3*4", "25=1+2*3*4"]
["1+2+3*4+5==2+3+4+5+6", "1*2+3+4*5==2+3*4+5+6"]
```

問4-2を、二組の整数から作る式を総当たりする代わりに、計算結果を連想配列に入れて比較するように改良してみます。

```ruby
class ExprSetFast
  attr_reader :exprMap

  def initialize(minNum, maxNum)
    @exprMap = {}
    exprSet = ((minNum+1)..maxNum).inject([minNum]) do |xs, i|
      xs.product(["+", "*"], [i])
    end.map(&:join)

    exprSet.each do |expr|
      key = eval(expr)
      @exprMap[key] = [] unless @exprMap.key?(key)
      @exprMap[key] << expr
    end
  end

  def printSums
    @exprMap.keys.sort.each { |key| @exprMap[key].each { |expr| puts "#{key} = #{expr}" }}
  end

  def printMatchedSums(other)
    other.exprMap.keys.sort.each do |key|
      next unless @exprMap.key?(key)
      puts (@exprMap[key] + other.exprMap[key]).join(" == ")
    end
  end
end
```

[総当たり:2008math4.rb](2008math4.rb)、[連想配列:2008math4b.rb](2008math4b.rb)版とも、スクリプトに何か引数をつけて起動すると、時間の掛かる問題を解くようになります。1..10と2..11から式を作って同じ計算結果になるものを選ぶと、確かに後者の方が速くなっています。

```text
time ruby 2008math4.rb 1
real    0m4.533s
user    0m4.359s
sys     0m0.140s

time ruby 2008math4b.rb 1
real    0m0.224s
user    0m0.062s
sys     0m0.140s
```

問題が大きくなると、速度だけではなくメモリの使用効率も重要になります。連想配列版の、

```ruby
ExprSetFast.new(1,17).printMatchedSums(ExprSetFast.new(2,18))
```

は数秒で完了します。しかし総当たり版の

```ruby
ExprSet.new(1,17).printMatchedSums(ExprSet.new(2,18))
```

は下記の出力通り、メモリを使い果たして異常終了するので答えが返ってきません。

```text
2008math4.rb:21:in `product': failed to allocate memory (NoMemoryError)
```

もっと悪いことに、これより少し小さい問題

```ruby
ExprSet.new(1,16).printMatchedSums(ExprSet.new(2,17))
```

は、システムのメモリを使い果たしてWindowsの動作そのものが遅くなるので(コミット済メモリがDRAM容量を超えてしまっている)、強制終了するのも大変になります。こうなるとWindowsを再起動するしかなくなります。64bit環境だからといって、あまり贅沢にメモリを使うのはよくないようですね。

## JavaScript

やはりevalが使えます。Rubyと同様の解き方なので、連想配列を使った解き方は省略します。

Node.jsで実行できます。実行には[js-combinatorics](https://github.com/dankogai/js-combinatorics)が必要です。

```javascript
var Combinatorics = require('js-combinatorics');

function expressions(minNum, maxNum) {
    var size = maxNum - minNum + 1;
    return Combinatorics.cartesianProduct(...(Array(size - 1).fill(['+', '*']))).map(function(xs) {
        var expr = [minNum]
        for(i=0; i<(size - 1); ++i) { expr.push(xs[i], minNum + i + 1); }
        return expr.join('');
    })
}

function printSums(minNum, maxNum) {
    expressions(minNum, maxNum).map(function(str) { return String(eval(str)) + " = " + str;
    }).sort (function(a,b) { return (parseInt(a) < parseInt(b)) ? -1 : 1;
    }).forEach (function(str) { console.log(str);
    })
}

function printMatchedSums(minNumLeft, maxNumLeft, minNumRight, maxNumRight) {
    expressions(minNumLeft, maxNumLeft).map(function(left) {
        expressions(minNumRight, maxNumRight).map(function(right) {
            var str = left + " == " + right;
            if (eval(str)) { console.log(str); }})})
}

printSums(1,4);
printMatchedSums(1,5,2,6);
```

## Java

JavaScriptのコードを文字列として組み立てて評価します。ソースコードの全文は[2008math4.java](2008math4.java)です。

```java
manager_ = new ScriptEngineManager();
engine_ = manager_.getEngineByName("javascript");
statement_ = "function evalExpr(expr) { return eval(expr); }";
engine_.eval(statement_);
funcName_ = "evalExpr";
invocable_ = (Invocable) engine_;
result = (Integer) invocable_.invokeFunction(funcName_, expr);
```

## Python

Pythonもevalが使えます。きっとpythonicな書き方があると思います。

```python
import itertools

def expression(nums, ops):
    expr = "".join(str(x) for x in list(itertools.chain(*zip(list(nums), list(ops)))))
    return [eval(expr), expr]

def expressions(minNum, maxNum):
    nums = list(range(minNum, maxNum + 1))
    opList = itertools.product(*(([["*", "+"]] * (maxNum - minNum)) + [[""]]))
    return sorted(list(map(lambda ops:expression(nums, ops), list(opList))), key=lambda x:x[0])

def printSums(minNum, maxNum):
    for result in expressions(minNum, maxNum):
        print(str(result[0]) + " = " + result[1])

def printMatchedSums(minNumLeft, maxNumLeft, minNumRight, maxNumRight):
    for resultLeft in expressions(minNumLeft, maxNumLeft):
        for resultRight in expressions(minNumRight, maxNumRight):
            if resultLeft[0] == resultRight[0]:
                print (resultLeft[1] + " == " + resultRight[1])

printSums(1,4)
printMatchedSums(1, 5, 2, 6)
```

## Groovy

GroovyもEvalが使えます。私にとっては初めてのGroovyプログラミングなので、もっとよい書き方があると思います。

```groovy
class NumberSetG {
    def resultSet_

    NumberSetG(minNum, maxNum) { resultSet_ = expressions(minNum, maxNum) }

    def PrintSums() { resultSet_.each { result -> println "" + result.head() + "=" + result.last() }}

    def PrintMatchedSums(NumberSetG other) {
        resultSet_.each{ r -> other.resultSet_.findAll { r.head() == it.head() }.
            each{println r.last() + " == " + it.last()} }
    }

    def expressions(minNum, maxNum) {
        getExprSet(minNum + 1, maxNum, [minNum.toString()]).inject([],
            { sum, expr -> sum + [evaluate(expr)]
        }).sort{ l,r -> l.head() <=> r.head() }
    }

    def getExprSet(minNum, maxNum, strSet) {
        def nextStrSet = strSet.inject([], { sum, str ->
            sum + [str + "*" + minNum.toString(), str + "+" + minNum.toString()]})
        (minNum == maxNum) ? nextStrSet : getExprSet(minNum + 1, maxNum, nextStrSet)
    }

    def evaluate(expr) { [Eval.me(expr), expr] }

    static main(args) {
        NumberSetG q1 = new NumberSetG(1,4)
        q1.PrintSums()
        NumberSetG q2l = new NumberSetG(1,5)
        NumberSetG q2r = new NumberSetG(2,6)
        q2l.PrintMatchedSums(q2r)
    }
}
```

## Scala

Scalaもevalが使えます。私にとっては初めてのScalaプログラミングなので、もっとよい書き方があると思います。

```scala
import scala.reflect.runtime.universe
import scala.tools.reflect.ToolBox

object NumberSet {
    def exprSet(minNum:Int, maxNum:Int) : List[(Any, String)] = {
        val nums = Range(minNum, maxNum + 1, 1).map(_.toString)
        val opSeq = List.fill(maxNum - minNum)(List("+", "*"))
        val opStrs = opSeq.foldLeft(List(""))((l, r) => l.flatMap { x => r.map{ y => x + y }})
        val opLists = opStrs.map(List("") ++ _.toList)
        val exprs = opLists.map(List(_, nums).transpose.flatten.mkString(""))
        val toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()
        exprs.map(expr => (toolbox.eval(toolbox.parse(expr)), expr))
    }

    def q1() : Unit = exprSet(1,4).sortBy{ case (x:Int, y) => x }.foreach(println _)
    def q2() : Unit = {
        exprSet(1,5).map{ case (l, lexpr) =>
            (l, exprSet(2,6).filter{case (r, _) => l == r}
                .map{case (r, rExpr) => lexpr + "==" + rExpr})
        }.filter{case (_, l) => !l.isEmpty}.foreach(println _)
    }

    def main(args: Array[String]) {
        q1()
        q2()
    }
}
```

```text
(9,1*2+3+4)
(10,1+2+3+4)
(10,1*2*3+4)
(11,1+2*3+4)
(14,1*2+3*4)
(15,1+2+3*4)
(24,1*2*3*4)
(25,1+2*3*4)
(20,List(1+2+3*4+5==2+3+4+5+6))
(25,List(1*2+3+4*5==2+3*4+5+6))
```

## Bash script

bcコマンドを使えばできます。

```bash
for exprStr in `echo 1{*,+}2{*,+}3{*,+}4`; do echo `echo $exprStr | bc` = $exprStr; done | sort -n

for left in `echo 1{+,*}2{+,*}3{+,*}4{+,*}5`; do
  for right in `echo 2{+,*}3{+,*}4{+,*}5{+,*}6`; do
    if [ `echo $left | bc` -eq `echo $right| bc` ] ; then
      echo $left "==" $right
    fi
  done
done
```

## Makefile

やはりbcコマンドを使えばできます。

```make
makelist=$(foreach v,$1+ $1*,$(addprefix $(v),$2))
LIST1TO4:=$(call makelist,1,$(call makelist,2,$(call makelist,3,4)))
LIST1TO5:=$(call makelist,1,$(call makelist,2,$(call makelist,3,$(call makelist,4,5))))
LIST2TO6:=$(call makelist,2,$(call makelist,3,$(call makelist,4,$(call makelist,5,6))))
Q2EXPRS:=$(foreach v1,$(LIST1TO5),$(foreach v2,$(LIST2TO6),$(addprefix $(v1)==,$(v2))))
q1=$(foreach v,$1,$(shell echo $(v)|bc) = $(v)::)
q2=$(filter %=1=::,$(foreach v,$1,$(v)=$(shell echo $(v)|bc)=::))
.PHONY: all force
all: force
	@echo $(call q1,$(LIST1TO4)) | sed -e 's/::/\n/g' | sed -e 's/^[ ]*//' | sort -n
	@echo $(call q2,$(Q2EXPRS)) | sed -e 's/::/\n/g' | sed -e 's/^[ ]*//' | sed -e 's/=1=//g'
```

```bash
make -f 2008math4.mk
```

## C++とBoost C++ Libraries

Boost C++ Libraries に含まれる、Boost Spiritを使うとよいでしょう。boost_1_63_0.zip (現時点での最新) に含まれる、libs/spirit/example/qi/calc_utree_ast.cpp がまさに四則演算の例ですので利用します。calc_utree_ast.cppについてのライセンスはBoost Software License ですので、以下をご参照ください。

http://www.boost.org/LICENSE_1_0.txt

ソースコードの全文は[2008math4.cpp](2008math4.cpp)です。make (引数なし)でビルドして実行します。下記に計算式のパーサだけ抜粋します。

```c++
template <typename Iterator>
struct calculator : boost::spirit::qi::grammar<Iterator, boost::spirit::ascii::space_type, BigNumber()> {
    boost::spirit::qi::rule<Iterator, boost::spirit::ascii::space_type, BigNumber()> expression, term, factor;
    calculator() : calculator::base_type(expression) {
        expression = term[boost::spirit::qi::_val = boost::spirit::qi::_1]
            >> *('+' >> term[boost::spirit::qi::_val += boost::spirit::qi::_1]);
        term = factor[boost::spirit::qi::_val = boost::spirit::qi::_1]
            >> *('*' >> factor[boost::spirit::qi::_val *= boost::spirit::qi::_1]);
        factor = boost::spirit::qi::uint_[boost::spirit::qi::_val = boost::spirit::qi::_1];
    }
};
```

C++版もRuby版と同様に、問4-2は連想配列を使った解き方の方が速いことを確認します。2008math4c.exeに引数"map"をつけて起動すると連想配列を使い、map以外の任意の引数をつけると総当たりで比較します。C++の方がRubyより速いので、C++版の方が問題は大きめにしてあります(1..15と2..16から作る式を比較する)。

```text
time ./2008math4c slow > /dev/null
real    0m3.797s
user    0m3.734s
sys     0m0.046s

time ./2008math4c map > /dev/null
real    0m0.271s
user    0m0.203s
sys     0m0.030s
```

## CとAssembly

C++よりもさらに長いので、[2008math4a.c](2008math4a.c)と[2008math4asm.s](2008math4asm.s)を見てください。簡単にアルゴリズムを説明すると以下の通りです。
* 一つの数字を12bitのビットフィールドで表現する。本問の計算結果は最大値が720なので計算結果は12ビットに収まり、5個の数字は64ビットレジスタに収まる。
* 演算子について、乗算を1、加算を0で表現する。5個の数字の演算順序を4ビットで表現する。
* 乗算について畳み込みを行う。つまりi番目の数字とi+1番目の数字の積をi+1番目の数字とし、i番目の数字を0にする
* 乗算がすべて終わったら、すべての数字を足す

## Haskell

Assemblyと同じ処理を、assemblyよりはるかに短く書けます。

```haskell
import Data.List
opToChar 0 = "+"
opToChar 1 = "*"
apply (x:y:xs) (0:os) = x + apply (y:xs) os
apply (x:y:xs) (1:os) = apply ((x*y):xs) os
apply (x:xs) _ = x

makePair nums ops = (value, str)
  where value = apply nums ops
        str = concat $ concat $ transpose [map show nums, map opToChar ops ++ [""]]

allLists minNum maxNum = map f opLists
  where nums = [minNum..maxNum]
        opLists = sequence (replicate (maxNum - minNum) [0,1])
        f ops = makePair nums ops

q1 = sort $ allLists 1 4
q2 = [(snd p, snd q) | p <- (allLists 1 5), q <- (allLists 2 6), fst p == fst q]
```

```text
*Main> q1
[(9,"1*2+3+4"),(10,"1*2*3+4"),(10,"1+2+3+4"),(11,"1+2*3+4"),
 (14,"1*2+3*4"),(15,"1+2+3*4"),(24,"1*2*3*4"),(25,"1+2*3*4")]
*Main> q2
[("1+2+3*4+5","2+3+4+5+6"),("1*2+3+4*5","2+3*4+5+6")]
```

## Clojure

同様の方法で解けます。実行には[clojure.math.combinatorics](https://github.com/clojure/math.combinatorics)が必要です。

```clojure
(use 'clojure.math.combinatorics)

(defn calc [num nums ops]
  (if (= 0 (count nums)) num
    (if (= "+" (first ops))
      (+ num (calc (first nums) (rest nums) (rest ops)))
      (calc (* num (first nums)) (rest nums) (rest ops)))))

(defn evalExpr [num nums ops]
   [(calc num nums ops), (cons num (interleave ops nums))])

(defn expressions [minNum maxNum]
  (sort-by first
        (map (fn [ops] (evalExpr minNum (range (+ 1 minNum) (+ 1 maxNum) 1) ops))
             (apply cartesian-product (repeat (- maxNum minNum) '("*" "+"))))))

(defn matchExpr [exprSetA exprSetB]
  (filter (fn [x] (== (first (first x)) (first (second x))))
          (apply cartesian-product [exprSetA exprSetB])))

(run! println (expressions 1 4))
(run! println (matchExpr (expressions 1 5) (expressions 2 6)))
```

```text
[9 (1 * 2 + 3 + 4)]
[10 (1 * 2 * 3 + 4)]
[10 (1 + 2 + 3 + 4)]
[11 (1 + 2 * 3 + 4)]
[14 (1 * 2 + 3 * 4)]
[15 (1 + 2 + 3 * 4)]
[24 (1 * 2 * 3 * 4)]
[25 (1 + 2 * 3 * 4)]
([20 (1 + 2 + 3 * 4 + 5)] [20 (2 + 3 + 4 + 5 + 6)])
([25 (1 * 2 + 3 + 4 * 5)] [25 (2 + 3 * 4 + 5 + 6)])
```

## Scheme

同様の方法で解けます。

```scheme
(define (opLists size)
  (define (appendOps ls accum)
    (append accum (list (append '(#\+) ls) (append '(#\*) ls))))
  (cond ((= size 0) '((#\+) (#\*)))
        (#t (let ((subLs (opLists (- size 1))))
              (fold appendOps '() subLs)))))

(define (numRange minNum maxNum)
  (cond ((= minNum maxNum) (list maxNum))
        (#t (append (list minNum) (numRange (+ minNum 1) maxNum)))))

(define (zip ls rs)
  (cond ((null? ls) '())
        (#t (append (list (car ls) (car rs))
                    (zip (list-tail ls 1) (list-tail rs 1))))))

(define (expressions minNum maxNum)
  (define (applyOps ops nums)
    (cond ((null? ops)
           (list-ref nums 0))
          ((eqv? (list-ref ops 0) #\+)
           (+ (list-ref nums 0) (applyOps (list-tail ops 1) (list-tail nums 1))))
          ((eqv? (list-ref ops 0) #\*)
           (applyOps (list-tail ops 1)
                     (append (list (* (list-ref nums 0) (list-ref nums 1)))
                             (list-tail nums 2))))))

  (let ((allOpLists (opLists (- (- maxNum minNum) 1)))
        (nums (numRange minNum maxNum)))
    (define (toString x)
      (append (list (car x) #\= (car nums)) (zip (list-tail x 1) (list-tail nums 1))))
    (define (applyToNums opList) (cons (applyOps opList nums) opList))
    (define (sortPairs x y) (< (car x) (car y)))
    (map toString (sort (map applyToNums allOpLists) sortPairs))))

(define (exprMatcher minNum maxNum)
  (let ((exprLeft (expressions minNum maxNum)))
    (lambda (exprRight)
      (define (matcher x)
        (cond ((= (car x) (car exprRight)) #t)
              (#t #f)))
      (define (concat x accum) (append accum (append x '(#\= #\=))))

      (let* ((exprs (map cddr (filter matcher exprLeft)))
             (candidates (fold concat '() exprs)))
        (cond ((null? candidates) #f)
              (#t (append candidates (cddr exprRight))))))))

(define (main args)
  ((print "")
   (print (expressions 1 4))
   (print (filter (lambda (x) x) (map (exprMatcher 1 5) (expressions 2 6))))
   (exit 0)))
```

Windows版Gaucheの出力は以下の通りです。

```text
((9 = 1 * 2 + 3 + 4) (10 = 1 + 2 + 3 + 4) (10 = 1 * 2 * 3 + 4) (11 = 1 + 2 * 3 + 4)
 (14 = 1 * 2 + 3 * 4) (15 = 1 + 2 + 3 * 4) (24 = 1 * 2 * 3 * 4) (25 = 1 + 2 * 3 * 4))
((1 + 2 + 3 * 4 + 5 = = 2 + 3 + 4 + 5 + 6) (1 * 2 + 3 + 4 * 5 = = 2 + 3 * 4 + 5 + 6))
```

## OCaml

同様の方法で解けますが、もっと短く書ける気がします。

```ocaml
let opToChar op =
  match op with
    | 0 -> "+"
    | _ -> "*";;

let opsToString ops = List.map (fun x -> opToChar x) ops;;
let numsToString nums = List.map (fun x -> string_of_int x) nums;;
let zipLists nums ops = List.combine (numsToString nums) (opsToString ops);;
let tailExpr nums ops = List.fold_right (fun (x,y) s -> String.concat x [y;s]) (zipLists (List.tl nums) ops) "";;
let expr nums ops = String.concat "" [string_of_int (List.hd nums); tailExpr nums ops];;

let rec calc nums ops =
  match ops with
    | 0::xs -> (List.hd nums) + (calc (List.tl nums) (List.tl ops))
    | 1::xs -> calc (List.append [(List.hd nums) * (List.nth nums 1)] (List.tl (List.tl nums))) (List.tl ops)
    | _ -> (List.hd nums);;

let sortPair l r = (fst l) - (fst r);;
let makePair nums ops = (calc nums ops, expr nums ops);;
let rec numList i maxNum = if (i == maxNum) then [maxNum] else List.append [i] (numList (i+1) maxNum);;

let rec opList s =
  match s with
    | 0 -> [[]]
    | _ -> List.concat (List.map (fun x -> [List.append [0] x; List.append [1] x]) (opList (s-1)));;

let rawExpressions minNum maxNum = List.map (fun x -> makePair (numList minNum maxNum) x) (opList (maxNum - minNum));;
let expressions minNum maxNum = List.sort sortPair (rawExpressions minNum maxNum);;
let pairString left right = String.concat "" [snd left; " == "; snd right; "\n"];;
let pairsToString left right = if ((fst right) == (fst left)) then (pairString left right) else ""
let filterPairs right minNum maxNum = List.map (fun left -> pairsToString left right) (expressions minNum maxNum);;

let q2 minNumLeft maxNumLeft minNumRight maxNumRight =
  List.concat (List.map (fun right -> filterPairs right minNumLeft maxNumLeft) (expressions minNumRight maxNumRight));;

List.iter (fun x -> print_string (String.concat "" [string_of_int(fst x); " = "; snd x; "\n"])) (expressions 1 4);;
List.iter (fun x -> print_string x) (List.filter (fun x -> String.length x > 0) (q2 1 5 2 6));;
```
