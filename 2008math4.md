# 麻布中学校 2008年 入試問題 算数 問4

問題は以下の通りです。

http://www.inter-edu.com/nyushi/2008/azabu/

これは総当たりしかなさそうですね。

## Ruby

メタプログラミングが使えます。コードを式として組み立てて、評価すると解けます。

```ruby
class ExprSet
  attr_reader :exprSet

  def initialize(minNum, maxNum)
    @exprSet = ((minNum+1)..maxNum).inject([minNum]) { |xs, i| xs.product(["+", "*"]).product([i]) }.map(&:join)
  end

  def printSums
    strSet = @exprSet.map{ |expr| "#{eval(expr)} = #{expr}"}
    width = strSet.map(&:length).max
    puts strSet.map { |str| str.rjust(width, " ") }.sort
  end

  def printMatchedSums(other)
    puts @exprSet.product(other.exprSet).map { |x| x.join(" == ") }.select { |x| eval x }
  end
end

ExprSet.new(1,4).printSums
ExprSet.new(1,5).printMatchedSums(ExprSet.new(2,6))
```

```text
 9 = 1*2+3+4
10 = 1*2*3+4
10 = 1+2+3+4
11 = 1+2*3+4
14 = 1*2+3*4
15 = 1+2+3*4
24 = 1*2*3*4
25 = 1+2*3*4
1+2+3*4+5 == 2+3+4+5+6
1*2+3+4*5 == 2+3*4+5+6
```

## Bash script

bcコマンドを使えばできます。

```bash
for exprStr in `echo 1{*,+}2{*,+}3{*,+}4`; do echo `echo $exprStr | bc` = $exprStr; done | sort -n

for left in `echo 1{+,*}2{+,*}3{+,*}4{+,*}5`; do
  for right in `echo 2{+,*}3{+,*}4{+,*}5{+,*}6`; do
    if [ `echo $left | bc` -eq `echo $right| bc` ] ; then
      echo $left "==" $right
    fi
  done
done
```

## C++

Boost C++ Libraries に含まれる、Boost Spiritを使うとよいでしょう。boost_1_63_0.zip (現時点での最新) に含まれる、libs/spirit/example/qi/calc_utree_ast.cpp がまさに四則演算の例ですので利用します。calc_utree_ast.cppについてのライセンスはBoost Software License ですので、以下をご参照ください。

http://www.boost.org/LICENSE_1_0.txt

ソースコードの全文は[2008math4.cpp](2008math4.cpp)です。make (引数なし)でビルドして実行します。下記に計算式のパーサだけ抜粋します。

```c++
template <typename Iterator>
struct calculator : boost::spirit::qi::grammar<Iterator, boost::spirit::ascii::space_type, BigNumber()> {
    boost::spirit::qi::rule<Iterator, boost::spirit::ascii::space_type, BigNumber()> expression, term, factor;
    calculator() : calculator::base_type(expression) {
        expression = term[boost::spirit::qi::_val = boost::spirit::qi::_1]
            >> *('+' >> term[boost::spirit::qi::_val += boost::spirit::qi::_1]);
        term = factor[boost::spirit::qi::_val = boost::spirit::qi::_1]
            >> *('*' >> factor[boost::spirit::qi::_val *= boost::spirit::qi::_1]);
        factor = boost::spirit::qi::uint_[boost::spirit::qi::_val = boost::spirit::qi::_1];
    }
};
```
