# 麻布中学校 2008年 入試問題 算数 問4

問題は以下の通りです。

http://www.inter-edu.com/nyushi/2008/azabu/

これは総当たりしかなさそうですね。

拙文で挙げた[プログラミング言語(リンク)](https://github.com/zettsu-t/zettsu-t.github.io/wiki/If-programming-languages-were)についてVBA, HTML, CSS以外を使い、Python, Groovy, Scheme, OCaml, Rustでも書きました。Cygwinターミナルから、makeを引数なしで実行すると、ビルド、実行、実行結果の検査を行います。

```bash
make
```

とにかくたくさんのプログラミング言語で書いてみることが本ページの目的なので、問4-2は以下の制限事項があります。
- 二組の整数から作る式を総当たりで比較しています。コードは簡潔になるかもしれませんが遅いです。可能であれば、計算結果を連想配列に入れるなど、もっと速く計算できると思います。
- 問4-1でみたように、整数a..bに足し算掛け算を適用して作る計算結果は、同一の値に対して複数の式がありえます。そのときは表示が冗長になります。

## Ruby

メタプログラミングが使えます。コードを式として組み立てて、評価すると解けます。

```ruby
class ExprSet
  attr_reader :exprSet

  def initialize(minNum, maxNum)
    @exprSet = ((minNum+1)..maxNum).inject([minNum]) do |xs, i|
      xs.product(["+", "*"], [i])
    end.map(&:join)
  end

  def printSums
    puts @exprSet.map{ |expr| "#{eval(expr)} = #{expr}"}.sort_by(&:to_i)
  end

  def printMatchedSums(other)
    puts @exprSet.product(other.exprSet).map { |x| x.join(" == ") }.select { |x| eval x }
  end

  # より詳しく報告する
  def printMatchedSumsAndValue(other)
    @exprSet.product(other.exprSet).map do |l,r|
      [l, [l, r].join(" == ")]
    end.select { |l,expr| eval expr }.each do |l,expr|
      puts (eval l).to_s + " : " + expr
    end
  end
end
```

```text
9 = 1*2+3+4
10 = 1+2+3+4
10 = 1*2*3+4
11 = 1+2*3+4
14 = 1*2+3*4
15 = 1+2+3*4
24 = 1*2*3*4
25 = 1+2*3*4
1+2+3*4+5 == 2+3+4+5+6
1*2+3+4*5 == 2+3*4+5+6
```

読みやすさを無視してソースコードをできる限り短くすると、[2008math4a.rb](2008math4a.rb)のように185 bytesになります。

```ruby
e=->(m,n){(m+1..n).inject([m]){|x,i|x.product(["+","*"],[i])}.map &:join}
p e[1,4].map{|x|"#{eval x}=#{x}"}.sort_by &:to_i
p e[1,5].product(e[2,6]).map{|x|x.join"=="}.select{|x|eval x}
```

```text
["9=1*2+3+4", "10=1+2+3+4", "10=1*2*3+4", "11=1+2*3+4",
 "14=1*2+3*4", "15=1+2+3*4", "24=1*2*3*4", "25=1+2*3*4"]
["1+2+3*4+5==2+3+4+5+6", "1*2+3+4*5==2+3*4+5+6"]
```

問4-2を、二組の整数から作る式を総当たりする代わりに、計算結果を連想配列に入れて比較するように改良してみます。

```ruby
class ExprSetFast
  attr_reader :exprMap

  def initialize(minNum, maxNum)
    @exprMap = {}
    exprSet = ((minNum+1)..maxNum).inject([minNum]) do |xs, i|
      xs.product(["+", "*"], [i])
    end.map(&:join)

    exprSet.each do |expr|
      key = eval(expr)
      @exprMap[key] = [] unless @exprMap.key?(key)
      @exprMap[key] << expr
    end
  end

  def printSums
    @exprMap.keys.sort.each { |key| @exprMap[key].each { |expr| puts "#{key} = #{expr}" }}
  end

  def printMatchedSums(printValue, other)
    other.exprMap.keys.sort.each do |key|
      next unless @exprMap.key?(key)
      str = printValue ? (key.to_s + " : ") : ""
      str += (@exprMap[key] + other.exprMap[key]).join(" == ")
      puts str
    end
  end
end
```

[総当たり:2008math4.rb](2008math4.rb)、[連想配列:2008math4b.rb](2008math4b.rb)版とも、スクリプトに4つの引数a, b, c, dをつけて起動すると、a..bとc..dから作る式を比較する問題を解くようになります。後者の方が速くなっています。

```text
time ruby 2008math4.rb 1 10 2 11 > /dev/null
real    0m4.498s
user    0m4.343s
sys     0m0.125s

time ruby 2008math4b.rb 1 10 2 11 > /dev/null
real    0m0.254s
user    0m0.062s
sys     0m0.156s
```

問題が大きくなると、速度だけではなくメモリの使用効率も重要になります。連想配列版の、

```ruby
ExprSetFast.new(1,17).printMatchedSums(ExprSetFast.new(2,18))
```

は数秒で完了します。しかし総当たり版の

```ruby
ExprSet.new(1,17).printMatchedSums(ExprSet.new(2,18))
```

は下記の出力通り、メモリを使い果たして異常終了するので答えが返ってきません。

```text
2008math4.rb:21:in `product': failed to allocate memory (NoMemoryError)
```

もっと悪いことに、これより少し小さい問題

```ruby
ExprSet.new(1,16).printMatchedSums(ExprSet.new(2,17))
```

は、システムのメモリを使い果たしてWindowsの動作そのものが遅くなるので(コミット済メモリがDRAM容量を超えてしまっている)、強制終了するのも大変になります。こうなるとWindowsを再起動するしかなくなります。64bit環境だからといって、あまり贅沢にメモリを使うのはよくないようですね。

## JavaScript

やはりevalが使えます。Rubyと同様の解き方なので、連想配列を使った解き方は省略します。

Node.jsで実行できます。実行には[js-combinatorics](https://github.com/dankogai/js-combinatorics)が必要です。

```javascript
var Combinatorics = require('js-combinatorics');

function expressions(minNum, maxNum) {
    var size = maxNum - minNum + 1;
    return Combinatorics.cartesianProduct(...(Array(size - 1).fill(['+', '*']))).map(function(xs) {
        var expr = [minNum]
        for(i=0; i<(size - 1); ++i) { expr.push(xs[i], minNum + i + 1); }
        return expr.join('');
    })
}

function printSums(minNum, maxNum) {
    expressions(minNum, maxNum).map(function(str) { return String(eval(str)) + " = " + str;
    }).sort (function(a,b) { return (parseInt(a) < parseInt(b)) ? -1 : 1;
    }).forEach (function(str) { console.log(str);
    })
}

function printMatchedSums(minNumLeft, maxNumLeft, minNumRight, maxNumRight) {
    expressions(minNumLeft, maxNumLeft).map(function(left) {
        expressions(minNumRight, maxNumRight).map(function(right) {
            var str = left + " == " + right;
            if (eval(str)) { console.log(str); }})})
}

printSums(1,4);
printMatchedSums(1,5,2,6);
```

## Java

JavaScriptのコードを文字列として組み立てて評価します。ソースコードの全文は[2008math4.java](2008math4.java)です。

```java
manager_ = new ScriptEngineManager();
engine_ = manager_.getEngineByName("javascript");
statement_ = "function evalExpr(expr) { return eval(expr); }";
engine_.eval(statement_);
funcName_ = "evalExpr";
invocable_ = (Invocable) engine_;
result = (Integer) invocable_.invokeFunction(funcName_, expr);
```

## Python

Pythonもevalが使えます。きっとpythonicな書き方があると思います。

```python
import itertools

def expression(nums, ops):
    expr = "".join(str(x) for x in list(itertools.chain(*zip(list(nums), list(ops)))))
    return [eval(expr), expr]

def expressions(minNum, maxNum):
    nums = list(range(minNum, maxNum + 1))
    opList = itertools.product(*(([["*", "+"]] * (maxNum - minNum)) + [[""]]))
    return sorted(list(map(lambda ops:expression(nums, ops), list(opList))), key=lambda x:x[0])

def printSums(minNum, maxNum):
    for result in expressions(minNum, maxNum):
        print(str(result[0]) + " = " + result[1])

def printMatchedSums(printValue, minNumLeft, maxNumLeft, minNumRight, maxNumRight):
    for resultLeft in expressions(minNumLeft, maxNumLeft):
        for resultRight in expressions(minNumRight, maxNumRight):
            if resultLeft[0] == resultRight[0]:
                print (makeValueString(resultLeft[0], printValue) + resultLeft[1] + " == " + resultRight[1])

def makeValueString(value, enable):
    return (str(value) + " : ") if enable else ""
```

ここでは連想配列以外の解き方も示しましょう。a..bから立てた式の集合Lと、c..dから立てた式の集合Rを、それぞれ計算結果の昇順に並べ替えておきます。Lを計算結果の小さいほうから大きな方へ、Rのそれぞれの式と比べていきます。Rも計算結果で並べ替えてあるので、以下のように比較対象を狭めることができます。マージソートに似ていますね。
- Lのいま注目している式の計算結果が、Rのいま注目している式の計算結果より大きければ、次に計算結果が大きい式をRから取り出して比較する
- Lのいま注目している式の計算結果が、Rのいま注目している式の計算結果より小さければ、次に計算結果が大きい式をLから取り出して比較する
- Lのいま注目している式の計算結果が、Rのいま注目している式の計算結果と同じなら、それらが同じであることを出力する。Lの1個以上の式とRの1個以上の式について計算結果が同じなら、それらの式の組み合わせをすべて出力する。

```python
def printMatchedSumsFast(minNumLeft, maxNumLeft, minNumRight, maxNumRight):
    resultsRight = expressions(minNumRight, maxNumRight)
    sizeOfRight = len(resultsRight)
    indexRight = 0  # ある値を持つright群の最小のインデックス
    count = 0       # 同じ値を持つright群の式が何個あるか

    for resultLeft in expressions(minNumLeft, maxNumLeft):
        # 前のrightの値と比較する
        indexRight = indexRight - count
        if indexRight >= sizeOfRight:
            break
        count = 0
        while indexRight < sizeOfRight and resultLeft[0] >= resultsRight[indexRight][0]:
            if resultLeft[0] == resultsRight[indexRight][0]:
                print (makeValueString(resultLeft[0], True) + resultLeft[1] + " == " + resultsRight[indexRight][1])
                count += 1
            indexRight += 1
```

最初の引数として _fast_ をつけて起動すると上記の高速化を使った方法で解き、fast以外の任意の引数をつけると総当たりで比較します。1..10と2..11から作る式を比較すると、確かに速くなっているのが分かります。wcは出力の文字数を数えるコマンドで、両者の答えが同じことを確認するためのものです。

```text
time python3 2008math4.py slow 1 10 2 11 | wc
    206    1030   10724
real    0m6.322s
user    0m6.265s
sys     0m0.046s

time python3 2008math4.py fast 1 10 2 11 | wc
    206    1030   10724
real    0m0.100s
user    0m0.061s
sys     0m0.031s
```

## Groovy

GroovyもEvalが使えます。私にとっては初めてのGroovyプログラミングなので、もっとよい書き方があると思います。

```groovy
class NumberSetG {
    def resultSet_

    NumberSetG(minNum, maxNum) { resultSet_ = expressions(minNum, maxNum) }

    def PrintSums() { resultSet_.each { result -> println "" + result.head() + "=" + result.last() }}

    def PrintMatchedSums(NumberSetG other) {
        resultSet_.each{ r -> other.resultSet_.findAll { r.head() == it.head() }.
            each{println r.last() + " == " + it.last()} }
    }

    def expressions(minNum, maxNum) {
        getExprSet(minNum + 1, maxNum, [minNum.toString()]).inject([],
            { sum, expr -> sum + [evaluate(expr)]
        }).sort{ l,r -> l.head() <=> r.head() }
    }

    def getExprSet(minNum, maxNum, strSet) {
        def nextStrSet = strSet.inject([], { sum, str ->
            sum + [str + "*" + minNum.toString(), str + "+" + minNum.toString()]})
        (minNum == maxNum) ? nextStrSet : getExprSet(minNum + 1, maxNum, nextStrSet)
    }

    def evaluate(expr) { [Eval.me(expr), expr] }

    static main(args) {
        NumberSetG q1 = new NumberSetG(1,4)
        q1.PrintSums()
        NumberSetG q2l = new NumberSetG(1,5)
        NumberSetG q2r = new NumberSetG(2,6)
        q2l.PrintMatchedSums(q2r)
    }
}
```

## Scala

Scalaもevalが使えます。私にとっては初めてのScalaプログラミングなので、もっとよい書き方があると思います。

引数を何かつけると総当たりをやめるので少し速くなりますが、それでも実行速度がとても遅いです。これはevalに時間が掛かっているからです。プログラミングに便利な道具があるということと、それを実際に使ってもよいかどうかは、別の問題です。

```scala
import scala.reflect.runtime.universe
import scala.tools.reflect.ToolBox

object NumberSetS {
    def exprSet(minNum:Int, maxNum:Int) : List[(Any, String)] = {
        val nums = Range(minNum, maxNum + 1, 1).map(_.toString)
        val opSeq = List.fill(maxNum - minNum)(List("+", "*"))
        val opStrs = opSeq.foldLeft(List(""))((l, r) => l.flatMap { x => r.map{ y => x + y }})
        val opLists = opStrs.map(List("") ++ _.toList)
        val exprs = opLists.map(List(_, nums).transpose.flatten.mkString(""))
        val toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()

        val startTime = System.currentTimeMillis()
        val result = exprs.map(expr => (toolbox.eval(toolbox.parse(expr)), expr)).sortBy{ case (x:Int, y) => x }
        val elapsedTime = System.currentTimeMillis() - startTime
        println(elapsedTime + " msec")
        result
    }

    def q1() : Unit = exprSet(1,4).foreach(println _)
    def q2() : Unit = {
        exprSet(1,5).map{ case (l, lexpr) =>
            (l, exprSet(2,6).filter{case (r, _) => l == r}
                .map{case (r, rExpr) => lexpr + "==" + rExpr})
        }.filter{case (_, l) => !l.isEmpty}.foreach(println _)
    }

    def q2fast() : Unit = {
        val resultsRight = exprSet(2,6)
        var indexRight = 0
        var count = 0

        for (expr <- exprSet(1,5)) {
            indexRight -= count
            if (indexRight < resultsRight.length) {
                count = 0
                val leftValue = expr._1.asInstanceOf[Int]
                while ((indexRight < resultsRight.length) &&
                       (leftValue >= resultsRight(indexRight)._1.asInstanceOf[Int])) {
                    if (leftValue == resultsRight(indexRight)._1.asInstanceOf[Int]) {
                        val s = "(" + expr._1 + ",List(" + expr._2 + "==" + resultsRight(indexRight)._2 + "))"
                        println(s)
                        count += 1
                    }
                    indexRight += 1
                 }
            }
        }
    }

    def main(args: Array[String]) {
        q1()
        if (args.length == 0) {
            q2()
        } else {
            q2fast()
        }
    }
}
```

```text
$ scala 2008math4.scala 1
1450 msec
(9,1*2+3+4)
(10,1+2+3+4)
(10,1*2*3+4)
(11,1+2*3+4)
(14,1*2+3*4)
(15,1+2+3*4)
(24,1*2*3*4)
(25,1+2*3*4)
1218 msec
1188 msec
(20,List(1+2+3*4+5==2+3+4+5+6))
(25,List(1*2+3+4*5==2+3*4+5+6))
```

## Bash script

bcコマンドを使えばできます。

```bash
for exprStr in `echo 1{*,+}2{*,+}3{*,+}4`; do echo `echo $exprStr | bc` = $exprStr; done | sort -n

for left in `echo 1{+,*}2{+,*}3{+,*}4{+,*}5`; do
  for right in `echo 2{+,*}3{+,*}4{+,*}5{+,*}6`; do
    if [ `echo $left | bc` -eq `echo $right| bc` ] ; then
      echo $left "==" $right
    fi
  done
done
```

## Makefile

やはりbcコマンドを使えばできます。

```make
makelist=$(foreach v,$1+ $1*,$(addprefix $(v),$2))
LIST1TO4:=$(call makelist,1,$(call makelist,2,$(call makelist,3,4)))
LIST1TO5:=$(call makelist,1,$(call makelist,2,$(call makelist,3,$(call makelist,4,5))))
LIST2TO6:=$(call makelist,2,$(call makelist,3,$(call makelist,4,$(call makelist,5,6))))
Q2EXPRS:=$(foreach v1,$(LIST1TO5),$(foreach v2,$(LIST2TO6),$(addprefix $(v1)==,$(v2))))
q1=$(foreach v,$1,$(shell echo $(v)|bc) = $(v)::)
q2=$(filter %=1=::,$(foreach v,$1,$(v)=$(shell echo $(v)|bc)=::))
.PHONY: all force
all: force
	@echo $(call q1,$(LIST1TO4)) | sed -e 's/::/\n/g' | sed -e 's/^[ ]*//' | sort -n
	@echo $(call q2,$(Q2EXPRS)) | sed -e 's/::/\n/g' | sed -e 's/^[ ]*//' | sed -e 's/=1=//g'
```

```bash
make -f 2008math4.mk
```

## C++とBoost C++ Libraries

Boost C++ Libraries に含まれる、Boost Spiritを使うとよいでしょう。boost_1_63_0.zip (現時点での最新) に含まれる、libs/spirit/example/qi/calc_utree_ast.cpp がまさに四則演算の例ですので利用します。calc_utree_ast.cppについてのライセンスはBoost Software License ですので、以下をご参照ください。

http://www.boost.org/LICENSE_1_0.txt

ソースコードの全文は[2008math4.cpp](2008math4.cpp)です。make (引数なし)でビルドして実行します。下記に計算式のパーサだけ抜粋します。

```c++
template <typename Iterator>
struct calculator : boost::spirit::qi::grammar<Iterator, boost::spirit::ascii::space_type, BigNumber()> {
    boost::spirit::qi::rule<Iterator, boost::spirit::ascii::space_type, BigNumber()> expression, term, factor;
    calculator() : calculator::base_type(expression) {
        expression = term[boost::spirit::qi::_val = boost::spirit::qi::_1]
            >> *('+' >> term[boost::spirit::qi::_val += boost::spirit::qi::_1]);
        term = factor[boost::spirit::qi::_val = boost::spirit::qi::_1]
            >> *('*' >> factor[boost::spirit::qi::_val *= boost::spirit::qi::_1]);
        factor = boost::spirit::qi::uint_[boost::spirit::qi::_val = boost::spirit::qi::_1];
    }
};
```

C++版もRuby版と同様に、問4-2は連想配列を使った解き方の方が速いことを確認します。2008math4c.exeに引数"map"をつけて起動すると連想配列を使い、map以外の任意の引数をつけると総当たりで比較します。C++の方がRubyより速いので、C++版の方が問題は大きめにしてあります(1..15と2..16から作る式を比較する)。計算結果はsize_tで保持していますが(当方の実行環境では64bit)、ソースコードを書き換えてBoost.Multiprecisionを使うことも可能です。

```text
time ./2008math4c nomap 1 15 2 16 > /dev/null
real    0m0.750s
user    0m0.703s
sys     0m0.000s

time ./2008math4c map 1 15 2 16 > /dev/null
real    0m0.143s
user    0m0.125s
sys     0m0.000s
```

## CとAssembly

C++よりもさらに長いので、[2008math4a.c](2008math4a.c)と[2008math4asm.s](2008math4asm.s)を見てください。簡単にアルゴリズムを説明すると以下の通りです。
* 一つの数字を12bitのビットフィールドで表現する。本問の計算結果は最大値が720なので計算結果は12ビットに収まり、5個の数字は64ビットレジスタに収まる。
* 演算子について、乗算を1、加算を0で表現する。5個の数字の演算順序を4ビットで表現する。
* 乗算について畳み込みを行う。つまりi番目の数字とi+1番目の数字の積をi+1番目の数字とし、i番目の数字を0にする
* 乗算がすべて終わったら、すべての数字を足す

## Haskell

Assemblyと同じ処理を、assemblyよりはるかに短く書けます。ソースコードの全文は[2008math4.hs](2008math4.hs)です。

```haskell
import Data.List

opToChar 0 = "+"
opToChar 1 = "*"
apply (x:y:xs) (0:os) = x + apply (y:xs) os
apply (x:y:xs) (1:os) = apply ((x*y):xs) os
apply (x:xs) _ = x

makePair nums ops = (value, str)
  where value = apply nums ops
        str = concat $ concat $ transpose [Data.List.map show nums, Data.List.map opToChar ops ++ [""]]

allLists minNum maxNum = Data.List.map f opLists
  where nums = [minNum..maxNum]
        opLists = sequence (replicate (maxNum - minNum) [0,1])
        f ops = makePair nums ops

q1 = sort $ allLists 1 4
q2full leftMin leftMax rightMin rightMax =
  [(snd p, snd q) | p <- (allLists leftMin leftMax), q <- (allLists rightMin rightMax), fst p == fst q]
q2 = q2full 1 5 2 6
```

```text
*Main> q1
[(9,"1*2+3+4"),(10,"1*2*3+4"),(10,"1+2+3+4"),(11,"1+2*3+4"),
 (14,"1*2+3*4"),(15,"1+2+3*4"),(24,"1*2*3*4"),(25,"1+2*3*4")]
*Main> q2
[("1+2+3*4+5","2+3+4+5+6"),("1*2+3+4*5","2+3*4+5+6")]
```

連想配列を使うと速くなるでしょうか。C++版と同様、第一引数に"map"をつけて起動すると連想配列を使い、map以外の任意の引数をつけると総当たりで比較します。Ruby, Python, C++版と同様、続く引数に数字4個をa b c dと空白で区切って並べることで、式に与える数字の範囲をa..bとc..dとします。wcは出力の文字数を数えるものです。

```text
time ./2008math4hs map 1 12 2 13 | wc
      1       1   65944
real    0m3.486s
user    0m0.000s
sys     0m0.031s

time ./2008math4hs nomap 1 12 2 13 | wc
      1       1   65944
real    0m0.076s
user    0m0.000s
sys     0m0.000s
```

なんとHaskell版は、連想配列(multiMap)を使うと却って遅くなります。Haskellの関数は同じ引数で再度で呼び出すと既に評価した値を返す、つまりメモ化してくれます。ですので、総当たりで比較する値を作る時間を節約する方が、連想配列の出し入れに掛かる時間より速いようです。Haskellのオブジェクトは基本immutableなので、連想配列は書き換えるものではなく値を変えたものをコピーして使うということです。速いコードを書くには、実際に測るのが重要ですね。

さて問4-2は、調べる範囲を1増やすと式の数が2倍になる、つまり指数関数的に解く時間が増えるはずですが、実際のプログラムでもそうなっているでしょうか。下記のコマンドで確かめてみましょう。詳しいプロファイルが _log2008_hs.txt_ に出力されます。

```bash
make profile
```

演算子が13個以上では、timeコマンドで測った実行時間が2倍よりも大きく増えています。キャッシュのヒット率とか、ガベージコレクション (演算子15個では実行時間の16%を占める)とか、いろいろ要因がありそうですがこれだけでははっきりしません。興味のある方は調べると面白いと思います。

|演算子の数|8|9|10|11|12|13|14|15|
|------:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|
|解く時間(秒)|0.072|0.056|0.069|0.125|0.282|1.029|7.598|46.673|

## Clojure

同様の方法で解けます。実行には[clojure.math.combinatorics](https://github.com/clojure/math.combinatorics)が必要です。

```clojure
(use 'clojure.math.combinatorics)

(defn calc [num nums ops]
  (if (= 0 (count nums)) num
    (if (= "+" (first ops))
      (+ num (calc (first nums) (rest nums) (rest ops)))
      (calc (* num (first nums)) (rest nums) (rest ops)))))

(defn evalExpr [num nums ops]
   [(calc num nums ops), (cons num (interleave ops nums))])

(defn expressions [minNum maxNum]
  (sort-by first
        (map (fn [ops] (evalExpr minNum (range (+ 1 minNum) (+ 1 maxNum) 1) ops))
             (apply cartesian-product (repeat (- maxNum minNum) '("*" "+"))))))

(defn matchExpr [exprSetA exprSetB]
  (filter (fn [x] (== (first (first x)) (first (second x))))
          (apply cartesian-product [exprSetA exprSetB])))

(run! println (expressions 1 4))
(run! println (matchExpr (expressions 1 5) (expressions 2 6)))
```

```text
[9 (1 * 2 + 3 + 4)]
[10 (1 * 2 * 3 + 4)]
[10 (1 + 2 + 3 + 4)]
[11 (1 + 2 * 3 + 4)]
[14 (1 * 2 + 3 * 4)]
[15 (1 + 2 + 3 * 4)]
[24 (1 * 2 * 3 * 4)]
[25 (1 + 2 * 3 * 4)]
([20 (1 + 2 + 3 * 4 + 5)] [20 (2 + 3 + 4 + 5 + 6)])
([25 (1 * 2 + 3 + 4 * 5)] [25 (2 + 3 * 4 + 5 + 6)])
```

## Scheme

同様の方法で解けます。

```scheme
(define (opLists size)
  (define (appendOps ls accum)
    (append accum (list (append '(#\+) ls) (append '(#\*) ls))))
  (cond ((= size 0) '((#\+) (#\*)))
        (#t (let ((subLs (opLists (- size 1))))
              (fold appendOps '() subLs)))))

(define (numRange minNum maxNum)
  (cond ((= minNum maxNum) (list maxNum))
        (#t (append (list minNum) (numRange (+ minNum 1) maxNum)))))

(define (zip ls rs)
  (cond ((null? ls) '())
        (#t (append (list (car ls) (car rs))
                    (zip (list-tail ls 1) (list-tail rs 1))))))

(define (expressions minNum maxNum)
  (define (applyOps ops nums)
    (cond ((null? ops)
           (list-ref nums 0))
          ((eqv? (list-ref ops 0) #\+)
           (+ (list-ref nums 0) (applyOps (list-tail ops 1) (list-tail nums 1))))
          ((eqv? (list-ref ops 0) #\*)
           (applyOps (list-tail ops 1)
                     (append (list (* (list-ref nums 0) (list-ref nums 1)))
                             (list-tail nums 2))))))

  (let ((allOpLists (opLists (- (- maxNum minNum) 1)))
        (nums (numRange minNum maxNum)))
    (define (toString x)
      (append (list (car x) #\= (car nums)) (zip (list-tail x 1) (list-tail nums 1))))
    (define (applyToNums opList) (cons (applyOps opList nums) opList))
    (define (sortPairs x y) (< (car x) (car y)))
    (map toString (sort (map applyToNums allOpLists) sortPairs))))

(define (exprMatcher minNum maxNum)
  (let ((exprLeft (expressions minNum maxNum)))
    (lambda (exprRight)
      (define (matcher x)
        (cond ((= (car x) (car exprRight)) #t)
              (#t #f)))
      (define (concat x accum) (append accum (append x '(#\= #\=))))

      (let* ((exprs (map cddr (filter matcher exprLeft)))
             (candidates (fold concat '() exprs)))
        (cond ((null? candidates) #f)
              (#t (append candidates (cddr exprRight))))))))

(define (main args)
  ((print "")
   (print (expressions 1 4))
   (print (filter (lambda (x) x) (map (exprMatcher 1 5) (expressions 2 6))))
   (exit 0)))
```

Windows版Gaucheの出力は以下の通りです。

```text
((9 = 1 * 2 + 3 + 4) (10 = 1 + 2 + 3 + 4) (10 = 1 * 2 * 3 + 4) (11 = 1 + 2 * 3 + 4)
 (14 = 1 * 2 + 3 * 4) (15 = 1 + 2 + 3 * 4) (24 = 1 * 2 * 3 * 4) (25 = 1 + 2 * 3 * 4))
((1 + 2 + 3 * 4 + 5 = = 2 + 3 + 4 + 5 + 6) (1 * 2 + 3 + 4 * 5 = = 2 + 3 * 4 + 5 + 6))
```

## OCaml

同様の方法で解けますが、もっと短く書ける気がします。

```ocaml
let opToChar op =
  match op with
    | 0 -> "+"
    | _ -> "*";;

let opsToString ops = List.map (fun x -> opToChar x) ops;;
let numsToString nums = List.map (fun x -> string_of_int x) nums;;
let zipLists nums ops = List.combine (numsToString nums) (opsToString ops);;
let tailExpr nums ops = List.fold_right (fun (x,y) s -> String.concat x [y;s]) (zipLists (List.tl nums) ops) "";;
let expr nums ops = String.concat "" [string_of_int (List.hd nums); tailExpr nums ops];;

let rec calc nums ops =
  match ops with
    | 0::xs -> (List.hd nums) + (calc (List.tl nums) (List.tl ops))
    | 1::xs -> calc (List.append [(List.hd nums) * (List.nth nums 1)] (List.tl (List.tl nums))) (List.tl ops)
    | _ -> (List.hd nums);;

let sortPair l r = (fst l) - (fst r);;
let makePair nums ops = (calc nums ops, expr nums ops);;
let rec numList i maxNum = if (i == maxNum) then [maxNum] else List.append [i] (numList (i+1) maxNum);;

let rec opList s =
  match s with
    | 0 -> [[]]
    | _ -> List.concat (List.map (fun x -> [List.append [0] x; List.append [1] x]) (opList (s-1)));;

let rawExpressions minNum maxNum = List.map (fun x -> makePair (numList minNum maxNum) x) (opList (maxNum - minNum));;
let expressions minNum maxNum = List.sort sortPair (rawExpressions minNum maxNum);;
let pairString left right = String.concat "" [snd left; " == "; snd right; "\n"];;
let pairsToString left right = if ((fst right) == (fst left)) then (pairString left right) else ""
let filterPairs right minNum maxNum = List.map (fun left -> pairsToString left right) (expressions minNum maxNum);;

let q2 minNumLeft maxNumLeft minNumRight maxNumRight =
  List.concat (List.map (fun right -> filterPairs right minNumLeft maxNumLeft) (expressions minNumRight maxNumRight));;

List.iter (fun x -> print_string (String.concat "" [string_of_int(fst x); " = "; snd x; "\n"])) (expressions 1 4);;
List.iter (fun x -> print_string x) (List.filter (fun x -> String.length x > 0) (q2 1 5 2 6));;
```

## Rust

最後はRustです。

```rust
use std::string::String;
use std::string::ToString;
use std::vec::Vec;
use std::collections::LinkedList;
use std::env;

type ExprValue = usize;

struct Result {
    value : ExprValue,
    expr  : String
}

fn make_result(value : ExprValue, nums: Vec<ExprValue>, ops: Vec<ExprValue>) -> Result {
    let mut s : String = nums[0].to_string();
    let mut restnums = nums.clone();
    restnums.remove(0);
    for op in ops {
       if op == 0 {
          s += "+";
       } else {
          s += "*";
       }
       s += &restnums[0].to_string();
       restnums.remove(0);
    }

    let result = Result {value : value, expr : s};
    result
}

fn op_lists(x: ExprValue) -> LinkedList<Vec<ExprValue>> {
    let mut result : LinkedList<Vec<ExprValue>> = LinkedList::new();
    if x == 0 {
        result.push_back(vec![]);
    } else {
        for sub in op_lists(x - 1) {
            let elements : Vec<ExprValue> = vec![0,1];
            for element in elements {
                let mut s = sub.clone();
                s.push(element);
                result.push_back(s);
            }
        }
    }
    result
}

fn apply_op_lists(nums: Vec<ExprValue>, ops: Vec<ExprValue>) -> ExprValue {
    let mut result : ExprValue = nums[0];
    if ops.len() > 0 {
        let mut newnums = nums.clone();
        let mut newops = ops.clone();
        newnums.remove(0);
        newops.remove(0);
        if ops[0] == 0 {
            result = nums[0] + apply_op_lists(newnums, newops);
        } else {
            newnums[0] = newnums[0] * nums[0];
            result = apply_op_lists(newnums, newops);
        }
    }

    result
}

fn expressions(min_num: ExprValue, max_num: ExprValue) -> Vec<Result> {
    let mut results : Vec<Result> = Vec::new();
    for ops in op_lists(max_num - min_num) {
       let nums : Vec<ExprValue> = ((min_num)..(max_num+1)).collect();
       let vops = ops.clone();
       let vnums = nums.clone();
       let result = make_result(apply_op_lists(nums, ops), vnums, vops);
       results.push(result);
    }

    results.sort_by(|x,y| x.value.cmp(&y.value));
    results
}

fn q1(min_num: ExprValue, max_num: ExprValue) {
    for result in expressions(min_num, max_num) {
        println!("{} = {}", result.value, result.expr);
    }
}

fn q2(print_value: bool, min_left: ExprValue, max_left: ExprValue, min_right: ExprValue, max_right: ExprValue) {
    let right_exprs = expressions(min_right, max_right);
    let size = right_exprs.len();
    let mut index = 0;
    let mut count = 0;

    for left in expressions(min_left, max_left) {
        index -= count;
        if index >= size {
            break
        }

        count = 0;
        while index < size && left.value >= right_exprs[index].value {
            if left.value == right_exprs[index].value {
                if print_value {
                    println!("{} : {} == {}", left.value, left.expr, right_exprs[index].expr);
                } else {
                    println!("{} == {}", left.expr, right_exprs[index].expr);
                }
                count += 1;
            }
            index += 1;
        }
    }
}

fn main() {
    if env::args().len() < 5 {
        q1(1,4);
        q2(false, 1,5,2,6);
    } else {
        let args : Vec<String> = env::args().collect();
        q2(true,
           args[1].parse::<ExprValue>().unwrap(),
           args[2].parse::<ExprValue>().unwrap(),
           args[3].parse::<ExprValue>().unwrap(),
           args[4].parse::<ExprValue>().unwrap());
    }
}
```

C++と同じサイズの問題を解かせてみましょう。

```text
time ./2008math4rs 1 15 2 16 > /dev/null
real    0m0.190s
user    0m0.015s
sys     0m0.000s
```

なんとC++並みの時間で解けました。C++版のパーサはBoost Spirit、Rust版は手書きの簡易版パーサなので実装が違うのですが、それにしてもRust速いです。もっと問題を大きくしても、Rust結構速いです。

```text
Rust : time ./2008math4rs 1 19 2 20 > /dev/null
real    0m3.598s
user    0m0.000s
sys     0m0.000s

C++ : time ./2008math4c map 1 19 2 20 > /dev/null
real    0m2.422s
user    0m2.375s
sys     0m0.031s
```
